
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Foundations III: Solving linear systems for model fitting &#8212; equadratures</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/footer.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/cards.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../_static/eq-logo-favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Uncertainty quantification in computational fluid dynamics" href="tutorial_4.html" />
    <link rel="prev" title="Foundations II: Orthogonal polynomials" href="tutorial_2.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../index.html">
  <img src="../_static/logo_new.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="tutorials.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="documentation.html">
  Documentation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="research.html">
  Research
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="apps.html">
  Apps
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="developers.html">
  Developers
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://discourse.equadratures.org/">Discourse<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/Effective-Quadratures/equadratures" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/equadratures" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search equadratures..." aria-label="Search equadratures..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <p class="caption">
 <span class="caption-text">
  List of tutorials
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_1.html">
   Foundations I: Parameter
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_2.html">
   Foundations II: Orthogonal polynomials
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Foundations III: Solving linear systems for model fitting
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_4.html">
   Uncertainty quantification in computational fluid dynamics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_5.html">
   Uncertainty quantification with correlations for a borehole model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_6.html">
   Sensitivity analysis for a piston model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_7.html">
   Data-driven dimension reduction in turbomachinery
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_8.html">
   Adjoint/gradient-enhanced surrogate modelling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_9.html">
   Surrogate-based design optimisation on Rosenbrock’s function
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_10.html">
   Machine learning California housing with interpretable polynomial trees
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_11.html">
   Time-series remaining useful life prediction with spatio-temporal polynomials
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_12.html">
   Flow-field estimation using vector-valued polynomial ridge approximations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial_13.html">
   Multi-fidelity Bayesian polynomials on turbine cascade experiments
  </a>
 </li>
</ul>

  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tensor-grid-quadrature">
   Tensor-grid quadrature
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#total-order-least-squares">
   Total-order least squares
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusions">
   Conclusions
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="foundations-iii-solving-linear-systems-for-model-fitting">
<h1>Foundations III: Solving linear systems for model fitting<a class="headerlink" href="#foundations-iii-solving-linear-systems-for-model-fitting" title="Permalink to this headline">¶</a></h1>
<p>In this final foundation tutorial, let’s apply the tools we introduced in the previous two tutorials. Consider the Rosenbrock’s function in 2D</p>
<div class="math notranslate nohighlight">
\[f(x_1, x_2) = (1 - x_1)^2 + 100 (x_2 - x_1^2)^2\]</div>
<p>with <span class="math notranslate nohighlight">\(x_1, x_2\)</span> uniformly distributed in <span class="math notranslate nohighlight">\([-1, 1]\)</span>. Suppose that we want to fit a polynomial model for this function, e.g. to estimate its output moments. In EQ, models are composed using the <cite>Poly</cite> object, which encapsulates the function</p>
<div class="math notranslate nohighlight">
\[g(\mathbf{x}) = \sum_{i=1}^P c_i \psi_i(\mathbf{x}) \qquad (1)\]</div>
<p>where <span class="math notranslate nohighlight">\(\psi_i(\mathbf{x})\)</span> are the orthogonal polynomials defined on a certain basis, as we mentioned in the last tutorial. Fitting the polynomial amounts to solving for the coefficients <span class="math notranslate nohighlight">\(c_i\)</span>. In practice, this is equivalent to <em>solving a linear system</em></p>
<div class="math notranslate nohighlight">
\[\mathbf{Ac} = \mathbf{b} \qquad (2)\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{A}(i, j) = \psi_j(\mathbf{x}_i)\)</span> (similar to the Vandermonde type matrix in the previous tutorial), and <span class="math notranslate nohighlight">\(b(i) = f(\mathbf{x_i})\)</span> contain function evaluations. In most practical problems, function evaluations are expensive, and we wish to obtain the most accurate model with the fewest amount of function evaluations. How many function evaluations do we need to solve the linear system? Let’s explore this question by examining two example solver methods in EQ. Before we dive in, let’s define the function and set up the preliminaries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">equadratures</span> <span class="k">as</span> <span class="nn">eq</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="n">x0</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">distribution</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">lower</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">distribution</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">lower</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">my_param_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="tensor-grid-quadrature">
<h2>Tensor-grid quadrature<a class="headerlink" href="#tensor-grid-quadrature" title="Permalink to this headline">¶</a></h2>
<p>First, coefficients can be solved in EQ using <em>numerical integration</em>. Why integration? If we multiply the equation (1) above with <span class="math notranslate nohighlight">\(\psi_j(\mathbf{x})\)</span> and integrate, we get</p>
<div class="math notranslate nohighlight">
\[\int g(\mathbf{x}) \psi_j(\mathbf{x}) dx = \int \sum_{i=1}^P c_i \psi_i(\mathbf{x}) \psi_j(\mathbf{x}) dx = c_j\]</div>
<p>Owing to the <em>orthogonality</em> of the basis functions we chose, every term vanishes except for the j-th term. Thus, coefficients can be solved effectively by integration, provided that the integral is evaluated accurately. This is handled via various quadrature methods in EQ. For example, if we choose to use tensor grid, Gauss-Legendre quadrature is a proven heuristic that solves the system to a high degree of accuracy. In code, this is handled with the following.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_basis</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">Basis</span><span class="p">(</span><span class="s1">&#39;tensor-grid&#39;</span><span class="p">)</span>
<span class="n">my_poly</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">Poly</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">my_param_list</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">my_basis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;numerical-integration&#39;</span><span class="p">)</span>
<span class="n">my_poly</span><span class="o">.</span><span class="n">set_model</span><span class="p">(</span><span class="n">rosenbrock</span><span class="p">)</span>
</pre></div>
</div>
<p>The first line declares the suitable basis for us to use, which is fed to the Poly object in the second line. We specify that we want to solve the coefficient via numerical integration. The third line initiates and executes the solver within the Poly object to set the coefficients in Poly.</p>
<p>How good is the fit? We can evaluate the goodness of fit on a select number of points to test how well our model does. The following code evaluates <span class="math notranslate nohighlight">\(R^2\)</span> scores (between 0 and 1) for the goodness of fit on the training points (points used to fit the polynomial model) and some testing points which we set as a uniform grid on the input domain. The latter is a good indication of how well the model performs in the domain of interest and whether the model has overfitted—of course, at the cost of extra model evaluations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mf">1.1</span><span class="p">:</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mf">1.1</span><span class="p">:</span><span class="mf">0.1</span><span class="p">]</span>
<span class="n">test_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">test_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">test_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
<span class="n">test_evals</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">evaluate_model</span><span class="p">(</span><span class="n">test_pts</span><span class="p">,</span> <span class="n">rosenbrock</span><span class="p">)</span>
<span class="n">train_r2</span><span class="p">,</span> <span class="n">test_r2</span> <span class="o">=</span> <span class="n">my_poly</span><span class="o">.</span><span class="n">get_polyscore</span><span class="p">(</span><span class="n">X_test</span><span class="o">=</span><span class="n">test_pts</span><span class="p">,</span> <span class="n">y_test</span><span class="o">=</span><span class="n">test_evals</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">train_r2</span><span class="p">,</span> <span class="n">test_r2</span><span class="p">)</span>
</pre></div>
</div>
<p>We should find that both the train and test scores are very close to 1. This is expected, since the function we are fitting is a polynomial!</p>
<p>Note that this method relies entirely on numerical quadrature methods. An implication of this is that we are restricted to certain types of basis, namely the tensor grid and sparse grid. In addition, one function evaluation is required per basis term we have. In this example, we needed <span class="math notranslate nohighlight">\(5^2 = 25\)</span> evaluations, but in high dimensions, the number of terms of these grids can be very prohibitive. Suppose that we cannot afford 25 evaluations. Can we solve the coefficients with fewer?</p>
</div>
<div class="section" id="total-order-least-squares">
<h2>Total-order least squares<a class="headerlink" href="#total-order-least-squares" title="Permalink to this headline">¶</a></h2>
<p>The least squares method focuses on the linear system (2) and finds coefficients that minimises the 2-norm error, i.e. the total squared error between prediction (<span class="math notranslate nohighlight">\(\mathbf{Ac}\)</span>) and true function evaluations (<span class="math notranslate nohighlight">\(\mathbf{b}\)</span>). An immediate advantage here is that we are not restricted to any type of basis. Instead of using the tensor grid, let’s use the total order basis, which only has 15 basis terms.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_basis</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">Basis</span><span class="p">(</span><span class="s1">&#39;total-order&#39;</span><span class="p">)</span>
<span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">evaluate_model</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">rosenbrock</span><span class="p">)</span>
<span class="n">my_poly</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">Poly</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">my_param_list</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">my_basis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;least-squares&#39;</span><span class="p">,</span>
                                <span class="n">sampling_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;mesh&#39;</span><span class="p">:</span><span class="s1">&#39;user-defined&#39;</span><span class="p">,</span> <span class="s1">&#39;sample-points&#39;</span><span class="p">:</span><span class="n">X_train</span><span class="p">,</span>
                                                                <span class="s1">&#39;sample-outputs&#39;</span><span class="p">:</span><span class="n">y_train</span><span class="p">})</span>
<span class="n">my_poly</span><span class="o">.</span><span class="n">set_model</span><span class="p">()</span>
</pre></div>
</div>
<p>Note the other salient difference here: we are free to set the points where we evaluate the function. A simple—but often effective—approach is to simply select points randomly according to the input distribution, i.e. the uniform distribution. The selected points and corresponding function evaluations are fed to the Poly object instead of the function itself.</p>
<p>How many function evaluations do we need? Here, we used 20. For least squares generally, the number of evaluations needs to be at least larger than the number of basis terms. The more function evaluations used, the more stable the solution is going to be against small perturbations. Again, we can see how this model performs by using the <code class="code docutils literal notranslate"><span class="pre">get_polyscore</span></code> method.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mf">1.1</span><span class="p">:</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mf">1.1</span><span class="p">:</span><span class="mf">0.1</span><span class="p">]</span>
<span class="n">test_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">test_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">test_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
<span class="n">test_evals</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">evaluate_model</span><span class="p">(</span><span class="n">test_pts</span><span class="p">,</span> <span class="n">rosenbrock</span><span class="p">)</span>
<span class="n">train_r2</span><span class="p">,</span> <span class="n">test_r2</span> <span class="o">=</span> <span class="n">my_poly</span><span class="o">.</span><span class="n">get_polyscore</span><span class="p">(</span><span class="n">X_test</span><span class="o">=</span><span class="n">test_pts</span><span class="p">,</span> <span class="n">y_test</span><span class="o">=</span><span class="n">test_evals</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">train_r2</span><span class="p">,</span> <span class="n">test_r2</span><span class="p">)</span>
</pre></div>
</div>
<p>which should give us values close to 1 again.</p>
</div>
<div class="section" id="conclusions">
<h2>Conclusions<a class="headerlink" href="#conclusions" title="Permalink to this headline">¶</a></h2>
<p>This tutorial showcased two solution methods in EQ, but this merely scratches the surface of the many coefficient solving strategies in EQ. To mention a few more examples:</p>
<ul class="simple">
<li><p>Compressed sensing allows us to surpass the restriction that we need more function evaluations than basis terms, but we need to assume some special structure in the solution.</p></li>
<li><p>Elastic net promotes sparsity in the solution, which can improve the model’s generalisation capabilities.</p></li>
<li><p>Subsampling strategies (such as QR column pivoting) allow us to maximise the utility of a limited number of function evaluations.</p></li>
<li><p>Dimension reduction methods exploit special low-dimensional structures in functions to drastically reduce the number of function evaluations required to fit a model.</p></li>
</ul>
<p>In the other tutorials, these methods are explored in further details.</p>
</div>
</div>


              </div>
              
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer>
<div align="center"> 
<div class="logos">
<a href="https://github.com/Effective-Quadratures/Effective-Quadratures"><i class="fab fa-github"></i></a>   
<a href="https://effectivequadratures.slack.com/"><i class="fab fa-slack"></i></a>   
<a href="https://twitter.com/EQuadratures"><i class="fab fa-twitter"></i></a>   
<a href="https://discourse.equadratures.org"><i class="fab fa-discourse"></i></a>   
<a href="https://www.linkedin.com/company/effective-quadratures/about/"><i class="fab fa-linkedin"></i></a>   
<a href="https://www.youtube.com/channel/UCpjwFDSZuFbzW-2lj6d96dA"><i class="fab fa-youtube"></i></a>   
</div>

<span>Made by the Effective Quadratures Team, with ❤️</span>    
<span>Copyright © 2016-2021 by equadratures.org</span>    
<span> <a href="mailto:contact@equadratures.org">contact@equadratures.org</a> </span>   
</div>
</footer>
  </body>
</html>