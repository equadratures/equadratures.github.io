
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>equadratures.poly &#8212; equadratures</title>
    
  <link rel="stylesheet" href="../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/footer.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/cards.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/fonts.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.d3f166471bb80abb5163.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    <a class="navbar-brand" href="../../documentation.html">
    
      <p class="title"> </p>
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="../../parameter.html">Parameter</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../basis.html">Basis</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../poly.html">Polynomial</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../subspaces.html">Dimension reduction with polynomials</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../optimisation.html">Optimisation with polynomials</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../polytree.html">Polynomial Regression Trees</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../solver.html">Linear system solvers</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../quadrature.html">Quadrature</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../weight.html">Prescribing probability functions</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../correlated.html">Correlations</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../scalers.html">Scalers</a>
        </li>
        
        
        <li class="nav-item">
            <a class="nav-link nav-external" href="https://discourse.equadratures.org/">Discourse<i class="fas fa-external-link-alt"></i></a>
        </li>
        
      </ul>


      

      <ul class="navbar-nav">
        
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search equadratures..." aria-label="Search equadratures..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for equadratures.poly</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;The polynomial parent class; one of the main building blocks in Effective Quadratures.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">equadratures.stats</span> <span class="kn">import</span> <span class="n">Statistics</span>
<span class="kn">from</span> <span class="nn">equadratures.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">equadratures.basis</span> <span class="kn">import</span> <span class="n">Basis</span>
<span class="kn">from</span> <span class="nn">equadratures.solver</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="kn">from</span> <span class="nn">equadratures.subsampling</span> <span class="kn">import</span> <span class="n">Subsampling</span>
<span class="kn">from</span> <span class="nn">equadratures.quadrature</span> <span class="kn">import</span> <span class="n">Quadrature</span>
<span class="kn">from</span> <span class="nn">equadratures.datasets</span> <span class="kn">import</span> <span class="n">score</span>
<span class="kn">import</span> <span class="nn">equadratures.plot</span> <span class="k">as</span> <span class="nn">plot</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">st</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="n">MAXIMUM_ORDER_FOR_STATS</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">CARD_LIMIT_SOFT</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">50e3</span><span class="p">)</span>

<div class="viewcode-block" id="Poly"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly">[docs]</a><span class="k">class</span> <span class="nc">Poly</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Definition of a polynomial object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parameters : list</span>
<span class="sd">        A list of parameters, where each element of the list is an instance of the Parameter class.</span>
<span class="sd">    basis : Basis</span>
<span class="sd">        An instance of the Basis class corresponding to the multi-index set used.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        The method used for computing the coefficients. Should be one of: ``compressed-sensing``, ``least-squares``, ``minimum-norm``, ``numerical-integration``, ``least-squares-with-gradients``, ``least-absolute-residual``, ``huber``, ``elastic-net``, ``relevance-vector-machine`` or ``custom-solver``. See :class:`~equadratures.solver.Solver` for further details.</span>
<span class="sd">    sampling_args : dict, optional</span>
<span class="sd">        A dict containing optional arguments centered around the specific sampling strategy:</span>

<span class="sd">            - **mesh** (str): Avaliable options are: ``monte-carlo``, ``sparse-grid``, ``tensor-grid``, ``induced``, or ``user-defined``. Note that when the ``sparse-grid`` option is invoked, the sparse pseudospectral approximation method [1] is the adopted. One can think of this as being the correct way to use sparse grids in the context of polynomial chaos [2] techniques.</span>
<span class="sd">            - **subsampling-algorithm** (str): The ``subsampling-algorithm`` input refers to the optimisation technique for subsampling. In the aforementioned four sampling strategies, we generate a logarithm factor of samples above the required amount and prune down the samples using an optimisation technique (see [1]). Existing optimisation strategies include: ``qr``, ``lu``, ``svd``, ``newton``. These refer to QR with column pivoting [2], LU with row pivoting [3], singular value decomposition with subset selection [2] and a convex relaxation via Newton&#39;s method for determinant maximization [4]. Note that if the ``tensor-grid`` option is selected, then subsampling will depend on whether the Basis argument is a total order index set, hyperbolic basis or a tensor order index set.</span>
<span class="sd">            - **sampling-ratio** (float): Denotes the extent of undersampling or oversampling required. For values equal to unity (default), the number of rows and columns of the associated Vandermonde-type matrix are equal.</span>
<span class="sd">            - **sample-points** (numpy.ndarray): A numpy ndarray with shape (number_of_observations, dimensions) that corresponds to a set of sample points over the parameter space.</span>
<span class="sd">            - **sample-outputs** (numpy.ndarray): A numpy ndarray with shape (number_of_observations, 1) that corresponds to model evaluations at the sample points. Note that if ``sample-points`` is provided as an input, then the code expects ``sample-outputs`` too.</span>
<span class="sd">            - **sample-gradients** (numpy.ndarray): A numpy ndarray with shape (number_of_observations, dimensions) that corresponds to a set of sample gradient values over the parameter space.</span>
<span class="sd">    solver_args : dict, optional</span>
<span class="sd">        Optional arguments centered around the specific solver used for computing the coefficients. See :class:`Solver&lt;equadratures.solver.Solver&gt;`.</span>
<span class="sd">    override_cardinality: bool, optional</span>
<span class="sd">        Option to override the soft cardinality limit of 50E3. By default the limit is enforced in order to avoid excessively long run times when the polynomial coefficients are computed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Subsampling from a tensor grid</span>
<span class="sd">    &gt;&gt;&gt; param = eq.Parameter(distribution=&#39;uniform&#39;, lower=-1., upper=1., order=3)</span>
<span class="sd">    &gt;&gt;&gt; basis = eq.Basis(&#39;total order&#39;)</span>
<span class="sd">    &gt;&gt;&gt; poly = eq.Poly(parameters=[param, param], basis=basis, method=&#39;least-squares&#39; , sampling_args={&#39;mesh&#39;:&#39;tensor-grid&#39;, &#39;subsampling-algorithm&#39;:&#39;svd&#39;, &#39;sampling-ratio&#39;:1.0})</span>

<span class="sd">    &gt;&gt;&gt; # User-defined data with compressive sensing</span>
<span class="sd">    &gt;&gt;&gt; X = np.loadtxt(&#39;inputs.txt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = np.loadtxt(&#39;outputs.txt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; param = eq.Parameter(distribution=&#39;uniform&#39;, lower=-1., upper=1., order=3)</span>
<span class="sd">    &gt;&gt;&gt; basis = eq.Basis(&#39;total order&#39;)</span>
<span class="sd">    &gt;&gt;&gt; poly = eq.Poly([param, param], basis, method=&#39;compressive-sensing&#39;, sampling_args={&#39;sample-points&#39;:X_red,&#39;sample-outputs&#39;:Y_red})</span>

<span class="sd">    &gt;&gt;&gt; # Using a sparse grid</span>
<span class="sd">    &gt;&gt;&gt; param = eq.Parameter(distribution=&#39;uniform&#39;, lower=-1., upper=1., order=3)</span>
<span class="sd">    &gt;&gt;&gt; basis = eq.Basis(&#39;sparse-grid&#39;, level=7, growth_rule=&#39;exponential&#39;)</span>
<span class="sd">    &gt;&gt;&gt; poly = eq.Poly(parameters=[param, param], basis=basis, method=&#39;numerical-integration&#39;)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    1. Constantine, P. G., Eldred, M. S., Phipps, E. T., (2012) Sparse Pseudospectral Approximation Method. Computer Methods in Applied Mechanics and Engineering. 1-12. `Paper &lt;https://www.sciencedirect.com/science/article/pii/S0045782512000953&gt;`__</span>
<span class="sd">    2. Xiu, D., Karniadakis, G. E., (2002) The Wiener-Askey Polynomial Chaos for Stochastic Differential Equations. SIAM Journal on Scientific Computing,  24(2), `Paper &lt;https://epubs.siam.org/doi/abs/10.1137/S1064827501387826?journalCode=sjoce3&gt;`__</span>
<span class="sd">    3. Seshadri, P., Iaccarino, G., Ghisu, T., (2018) Quadrature Strategies for Constructing Polynomial Approximations. Uncertainty Modeling for Engineering Applications. Springer, Cham, 2019. 1-25. `Preprint &lt;https://arxiv.org/pdf/1805.07296.pdf&gt;`__</span>
<span class="sd">    4. Seshadri, P., Narayan, A., Sankaran M., (2017) Effectively Subsampled Quadratures for Least Squares Polynomial Approximations. SIAM/ASA Journal on Uncertainty Quantification, 5(1). `Paper &lt;https://epubs.siam.org/doi/abs/10.1137/16M1057668&gt;`__</span>
<span class="sd">    5. Rogers, S., Girolami, M., (2016) Variability in predictions. In: A First Course in Machine Learning, Second Edition (2nd. ed.). Chapman &amp; Hall/CRC. `Book &lt;https://github.com/wwkenwong/book/blob/master/Simon%20Rogers%2C%20Mark%20Girolami%20A%20First%20Course%20in%20Machine%20Learning.pdf&gt;`__</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampling_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">solver_args</span><span class="o">=</span><span class="p">{},</span> <span class="n">variable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">override_cardinality</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">parameters</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_args</span> <span class="o">=</span> <span class="n">sampling_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_args</span> <span class="o">=</span> <span class="n">solver_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">override</span> <span class="o">=</span> <span class="n">override_cardinality</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orders</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradient_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">orders</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">set_orders</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orders</span><span class="p">)</span>
        <span class="c1"># Initialize some default values!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_variances</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subsampling_algorithm_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_ratio</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters_order</span> <span class="o">=</span> <span class="p">[</span> <span class="n">parameter</span><span class="o">.</span><span class="n">order</span> <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highest_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;numerical-integration&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;integration&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">basis_type</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">basis_type</span> <span class="o">!=</span> <span class="s1">&#39;tensor-grid&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">basis_type</span> <span class="o">!=</span> <span class="s1">&#39;sparse-grid&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">basis_type</span> <span class="o">!=</span> <span class="s1">&#39;univariate&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tensor-grid or sparse-grid basis must be used with the numerical-integration Poly method&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;least-squares&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;least-absolute-residual&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">==</span><span class="s1">&#39;huber&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">==</span><span class="s1">&#39;elastic-net&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="s1">&#39;tensor-grid&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;least-squares-with-gradients&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gradient_flag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="s1">&#39;tensor-grid&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;compressed-sensing&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;compressive-sensing&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="s1">&#39;monte-carlo&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;minimum-norm&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="s1">&#39;monte-carlo&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;relevance-vector-machine&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="s1">&#39;monte-carlo&#39;</span>
            <span class="c1"># Now depending on user inputs, override these default values!</span>
            <span class="n">sampling_args_flag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="n">sampling_args</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">sampling_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">)</span>
                    <span class="n">sampling_args_flag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="s1">&#39;sampling-ratio&#39;</span> <span class="ow">in</span> <span class="n">sampling_args</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sampling_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sampling_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sampling-ratio&#39;</span><span class="p">))</span>
                    <span class="n">sampling_args_flag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="s1">&#39;subsampling-algorithm&#39;</span> <span class="ow">in</span> <span class="n">sampling_args</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">subsampling_algorithm_name</span> <span class="o">=</span> <span class="n">sampling_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;subsampling-algorithm&#39;</span><span class="p">)</span>
                    <span class="n">sampling_args_flag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="s1">&#39;sample-points&#39;</span> <span class="ow">in</span> <span class="n">sampling_args</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">sampling_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sample-points&#39;</span><span class="p">)</span>
                    <span class="n">sampling_args_flag</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="s1">&#39;user-defined&#39;</span>
                <span class="k">if</span> <span class="s1">&#39;sample-outputs&#39;</span> <span class="ow">in</span> <span class="n">sampling_args</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">sampling_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sample-outputs&#39;</span><span class="p">)</span>
                    <span class="n">sampling_args_flag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="s1">&#39;sample-gradients&#39;</span> <span class="ow">in</span> <span class="n">sampling_args</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gradients</span> <span class="o">=</span> <span class="n">sampling_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sample-gradients&#39;</span><span class="p">)</span>
                    <span class="n">sampling_args_flag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="s1">&#39;gram-schmidt-correction&#39;</span> <span class="ow">in</span> <span class="n">sampling_args</span><span class="p">:</span>
                    <span class="n">R_Psi</span> <span class="o">=</span> <span class="n">sampling_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gram-schmidt-correction&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inv_R_Psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R_Psi</span><span class="p">)</span>
                    <span class="n">sampling_args_flag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="s1">&#39;correlations&#39;</span> <span class="ow">in</span> <span class="n">sampling_args</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">corr</span> <span class="o">=</span> <span class="n">sampling_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;correlations&#39;</span><span class="p">)</span>
                    <span class="n">sampling_args_flag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">sampling_args_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;An input value that you have specified is likely incorrect. Sampling arguments include: mesh, sampling-ratio, subsampling-algorithm, sample-points, sample-outputs and sample-gradients.&#39;</span><span class="p">)</span>
                <span class="c1"># Additional optional sampling_args</span>
                <span class="k">if</span> <span class="s1">&#39;sample-outputs&#39;</span> <span class="ow">in</span> <span class="n">sampling_args</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">output_variances</span> <span class="o">=</span> <span class="n">sampling_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sample-output-variances&#39;</span><span class="p">)</span>

            <span class="c1"># Check cardinality before setting points and weights etc (unless override_cardinality=True)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">override</span><span class="p">:</span>
                <span class="n">cardinality</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">get_cardinality</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">cardinality</span> <span class="o">&gt;=</span> <span class="n">CARD_LIMIT_SOFT</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Cardinality </span><span class="si">%.1e</span><span class="s1"> &gt;= soft cardinality limit </span><span class="si">%.1e</span><span class="s1">. Computing polynomial coefficients may take a long time. To override this, set override_cardinality=True.&#39;</span>
                        <span class="o">%</span><span class="p">(</span><span class="n">cardinality</span><span class="p">,</span><span class="n">CARD_LIMIT_SOFT</span><span class="p">))</span>

            <span class="c1"># Set solver, points and weight etc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_solver</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_subsampling_algorithm</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_points_and_weights</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Method not declared.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Adds polynomials.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        poly</span>
<span class="sd">            An instance of the Poly class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polynew</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">polynew</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">coefficients</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span> <span class="n">polynew</span><span class="o">.</span><span class="n">_quadrature_points</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">_quadrature_points</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">polynew</span><span class="o">.</span><span class="n">_model_evaluations</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">_model_evaluations</span>
        <span class="k">return</span> <span class="n">polynew</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Subtracts polynomials.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        poly</span>
<span class="sd">            An instance of the Poly class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polynew</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">polynew</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">-=</span> <span class="n">other</span><span class="o">.</span><span class="n">coefficients</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span> <span class="n">polynew</span><span class="o">.</span><span class="n">_quadrature_points</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">_quadrature_points</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">polynew</span><span class="o">.</span><span class="n">_model_evaluations</span> <span class="o">-=</span> <span class="n">other</span><span class="o">.</span><span class="n">_model_evaluations</span>
        <span class="k">return</span> <span class="n">polynew</span>

<div class="viewcode-block" id="Poly.plot_polyfit_1D"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.plot_polyfit_1D">[docs]</a>    <span class="k">def</span> <span class="nf">plot_polyfit_1D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uncertainty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">output_variances</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">number_of_points</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Plots a 1D only polynomial fit to the data. See :meth:`~equadratures.plot.plot_polyfit_1D` for full description. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot</span><span class="o">.</span><span class="n">plot_polyfit_1D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="n">uncertainty</span><span class="p">,</span><span class="n">output_variances</span><span class="p">,</span><span class="n">number_of_points</span><span class="p">,</span><span class="n">show</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.plot_model_vs_data"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.plot_model_vs_data">[docs]</a>    <span class="k">def</span> <span class="nf">plot_model_vs_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;adjusted_r2&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Plots the polynomial approximation against the true data. See :meth:`~equadratures.plot.plot_model_vs_data` for full description. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot</span><span class="o">.</span><span class="n">plot_model_vs_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="n">sample_data</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="n">show</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.plot_sobol"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.plot_sobol">[docs]</a>    <span class="k">def</span> <span class="nf">plot_sobol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot; Plots a polynomial&#39;s Sobol&#39; indices of a given order. See :meth:`~equadratures.plot.plot_sobol` for full description. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot</span><span class="o">.</span><span class="n">plot_sobol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="n">order</span><span class="p">,</span><span class="n">show</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.plot_parameters"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.plot_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">plot_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Plots the probability density functions for all Parameters within a Polynomial. See :meth:`~equadratures.plot.plot_parameters` for full description. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot</span><span class="o">.</span><span class="n">plot_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">show</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.plot_total_sobol"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.plot_total_sobol">[docs]</a>    <span class="k">def</span> <span class="nf">plot_total_sobol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot; Plots a polynomial&#39;s total-order Sobol&#39; indices. See :meth:`~equadratures.plot.plot_total_sobol` for full description. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot</span><span class="o">.</span><span class="n">plot_total_sobol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="n">show</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.plot_sobol_heatmap"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.plot_sobol_heatmap">[docs]</a>    <span class="k">def</span> <span class="nf">plot_sobol_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generates a heatmap showing the first and second order Sobol indices. See :meth:`~equadratures.plot.plot_sobol_heatmap` for full description. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot</span><span class="o">.</span><span class="n">plot_sobol_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parameters</span><span class="p">,</span><span class="n">show</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Private function that sets the parameters. Required by the Correlated class. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_points_and_weights</span><span class="p">()</span>

<div class="viewcode-block" id="Poly.get_parameters"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the list of parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Contains the :class:`~equadratures.parameter.Parameter` objects belonging to the polynomial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span></div>

<div class="viewcode-block" id="Poly.get_summary"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_summary">[docs]</a>    <span class="k">def</span> <span class="nf">get_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tosay</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A simple utility that writes a file summarising what the polynomial approximation has determined.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            The filename to write to. If ``None``, the summary is written to *effective-quadratures-output.txt*.</span>
<span class="sd">        tosay : bool, optional</span>
<span class="sd">            True will replace &quot;-&quot; signs with &quot;minus&quot; when writing to file for compatibility with os.say().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:.3g}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">parameter_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;parameter.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parameter_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;parameters.&#39;</span><span class="p">)</span>
        <span class="n">introduction</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;Your problem has been defined by &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">parameter_string</span><span class="p">)</span>
        <span class="n">added</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;Their distributions are given as follows:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="n">added_new</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Parameter &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_description</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;This polynomial concerns the output variable &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">added</span> <span class="o">=</span> <span class="n">title</span> <span class="o">+</span> <span class="n">introduction</span> <span class="o">+</span> <span class="n">added_new</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">added</span> <span class="o">=</span> <span class="n">introduction</span> <span class="o">+</span> <span class="n">added_new</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">added</span> <span class="o">=</span> <span class="n">added</span> <span class="o">+</span> <span class="n">added_new</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mean_value</span><span class="p">,</span> <span class="n">var_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mean_and_variance</span><span class="p">()</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="n">y_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_polyfit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">y_valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span>
            <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">y_eval</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">y_valid</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">statistics</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> </span><span class="se">\n</span><span class="s1">A summary of computed output statistics is given below:</span><span class="se">\n</span><span class="s1">The mean is estimated to be &#39;</span><span class="o">+</span> <span class="n">prec</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mean_value</span><span class="p">)</span> <span class="o">+</span>\
                <span class="s1">&#39; while the variance is &#39;</span> <span class="o">+</span> <span class="n">prec</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var_value</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.</span><span class="se">\n</span><span class="s1">For the data avaliable, the polynomial approximation had a r square value of &#39;</span><span class="o">+</span><span class="n">prec</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r2</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sobol_indices_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_total_sobol_indices</span><span class="p">())</span>
                <span class="n">final_value</span> <span class="o">=</span> <span class="n">sobol_indices_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">statistics_extra</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Additionally, the most important parameter--based on the total Sobol indices--was found to be parameter &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">final_value</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
                <span class="n">statistics</span> <span class="o">=</span> <span class="n">statistics</span> <span class="o">+</span> <span class="n">statistics_extra</span>
            <span class="n">added</span> <span class="o">=</span> <span class="n">added</span> <span class="o">+</span> <span class="n">statistics</span>
            <span class="k">if</span><span class="p">(</span><span class="n">tosay</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span>
                <span class="n">added</span> <span class="o">=</span> <span class="n">added</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;e-&#39;</span><span class="p">,</span><span class="s1">&#39;e minus&#39;</span><span class="p">)</span>
                <span class="n">added</span> <span class="o">=</span> <span class="n">added</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;minus0&#39;</span><span class="p">,</span><span class="s1">&#39;minus&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;effective-quadratures-output.txt&#39;</span>
        <span class="n">output_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">added</span><span class="p">)</span>
        <span class="n">output_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_set_subsampling_algorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Private function that sets the subsampling algorithm based on the user-defined method. &quot;&quot;&quot;</span>
        <span class="n">polysubsampling</span> <span class="o">=</span> <span class="n">Subsampling</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subsampling_algorithm_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subsampling_algorithm_function</span> <span class="o">=</span> <span class="n">polysubsampling</span><span class="o">.</span><span class="n">get_subsampling_method</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Private function that sets the solver depending on the user-defined method. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="o">.</span><span class="n">select_solver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_args</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s2">&quot;elastic-net&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">elements</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span>

    <span class="k">def</span> <span class="nf">_set_points_and_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Private function that sets the quadrature points. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;corr&#39;</span><span class="p">):</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quadrature</span> <span class="o">=</span> <span class="n">Quadrature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span> \
                        <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="n">corr</span><span class="p">)</span>
        <span class="n">quadrature_points</span><span class="p">,</span> <span class="n">quadrature_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrature</span><span class="o">.</span><span class="n">get_points_and_weights</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsampling_algorithm_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="n">quadrature_points</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">quadrature_weights</span><span class="p">)))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">P</span>
            <span class="n">mm</span><span class="p">,</span> <span class="n">nn</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">m_refined</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_ratio</span> <span class="o">*</span> <span class="n">nn</span><span class="p">))</span>
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsampling_algorithm_function</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">m_refined</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span> <span class="o">=</span> <span class="n">quadrature_points</span><span class="p">[</span><span class="n">z</span><span class="p">,:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_weights</span> <span class="o">=</span> <span class="n">quadrature_weights</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">quadrature_weights</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span> <span class="o">=</span> <span class="n">quadrature_points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_weights</span> <span class="o">=</span> <span class="n">quadrature_weights</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="n">quadrature_points</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">quadrature_weights</span><span class="p">)))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">P</span>

<div class="viewcode-block" id="Poly.get_model_evaluations"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_model_evaluations">[docs]</a>    <span class="k">def</span> <span class="nf">get_model_evaluations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the output model evaluations used to fit the polynomial.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array containing the output model evaluations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span></div>

<div class="viewcode-block" id="Poly.get_mean_and_variance"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_mean_and_variance">[docs]</a>    <span class="k">def</span> <span class="nf">get_mean_and_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the mean and variance of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Tuple containing two floats; the approximated mean and variance from the polynomial fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_statistics</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span><span class="o">.</span><span class="n">get_mean</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span><span class="o">.</span><span class="n">get_variance</span><span class="p">()</span></div>

<div class="viewcode-block" id="Poly.get_skewness_and_kurtosis"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_skewness_and_kurtosis">[docs]</a>    <span class="k">def</span> <span class="nf">get_skewness_and_kurtosis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the skewness and kurtosis of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Tuple containing two floats; the approximated skewness and kurtosis from the polynomial fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_statistics</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span><span class="o">.</span><span class="n">get_skewness</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span><span class="o">.</span><span class="n">get_kurtosis</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_set_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Private method that is used within the statistics routines. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;inv_R_Psi&#39;</span><span class="p">):</span>
                <span class="c1"># quad_pts, quad_wts = self.quadrature.get_points_and_weights()</span>
                <span class="n">N_quad</span> <span class="o">=</span> <span class="mi">20000</span>
                <span class="n">quad_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="o">.</span><span class="n">get_correlated_samples</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N_quad</span><span class="p">)</span>
                <span class="n">quad_wts</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">N_quad</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_quad</span><span class="p">)</span>
                <span class="n">poly_vandermonde_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="n">quad_pts</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;numerical-integration&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">&lt;=</span> <span class="mi">6</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">highest_order</span> <span class="o">&lt;=</span> <span class="n">MAXIMUM_ORDER_FOR_STATS</span><span class="p">:</span>
                <span class="n">quad</span> <span class="o">=</span> <span class="n">Quadrature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">Basis</span><span class="p">(</span><span class="s1">&#39;tensor-grid&#39;</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters_order</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> \
                    <span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;tensor-grid&#39;</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">quad_pts</span><span class="p">,</span> <span class="n">quad_wts</span> <span class="o">=</span> <span class="n">quad</span><span class="o">.</span><span class="n">get_points_and_weights</span><span class="p">()</span>
                <span class="n">poly_vandermonde_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="n">quad_pts</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">==</span> <span class="s1">&#39;monte-carlo&#39;</span><span class="p">:</span>
                <span class="n">quad</span> <span class="o">=</span> <span class="n">Quadrature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span>
                                  <span class="n">basis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">oversampling</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)</span>
                <span class="n">quad_pts</span><span class="p">,</span> <span class="n">quad_wts</span> <span class="o">=</span> <span class="n">quad</span><span class="o">.</span><span class="n">get_points_and_weights</span><span class="p">()</span>
                <span class="n">N_quad</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quad_wts</span><span class="p">)</span>
                <span class="n">quad_wts</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">N_quad</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_quad</span><span class="p">)</span>
                <span class="n">poly_vandermonde_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="n">quad_pts</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">poly_vandermonde_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span><span class="p">)</span>
                <span class="n">quad_pts</span><span class="p">,</span> <span class="n">quad_wts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points_and_weights</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">highest_order</span> <span class="o">&lt;=</span> <span class="n">MAXIMUM_ORDER_FOR_STATS</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">basis_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;total-order&#39;</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">basis_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;hyperbolic-basis&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span> <span class="o">=</span> <span class="n">Statistics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">,</span>  <span class="n">quad_pts</span><span class="p">,</span> \
                        <span class="n">quad_wts</span><span class="p">,</span> <span class="n">poly_vandermonde_matrix</span><span class="p">,</span> <span class="n">max_sobol_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">highest_order</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span> <span class="o">=</span> <span class="n">Statistics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">,</span>  <span class="n">quad_pts</span><span class="p">,</span> \
                        <span class="n">quad_wts</span><span class="p">,</span> <span class="n">poly_vandermonde_matrix</span><span class="p">,</span> <span class="n">max_sobol_order</span><span class="o">=</span><span class="n">MAXIMUM_ORDER_FOR_STATS</span><span class="p">)</span>

<div class="viewcode-block" id="Poly.get_sobol_indices"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_sobol_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_sobol_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the Sobol&#39; indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : int</span>
<span class="sd">            The order of the Sobol&#39; indices required.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dict comprising of Sobol&#39; indices and constitutent mixed orders of the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_statistics</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span><span class="o">.</span><span class="n">get_sobol</span><span class="p">(</span><span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.get_total_sobol_indices"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_total_sobol_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_total_sobol_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the total Sobol&#39; indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of length d (number of input parameters) of total Sobol&#39; indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_statistics</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span><span class="o">.</span><span class="n">get_sobol_total</span><span class="p">()</span></div>

<div class="viewcode-block" id="Poly.get_conditional_skewness_indices"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_conditional_skewness_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_conditional_skewness_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the skewness indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : int</span>
<span class="sd">            The highest order of the skewness indices required.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dict comprising of skewness indices and constitutent mixed orders of the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_statistics</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span><span class="o">.</span><span class="n">get_conditional_skewness</span><span class="p">(</span><span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.get_conditional_kurtosis_indices"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_conditional_kurtosis_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_conditional_kurtosis_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the kurtosis indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : int</span>
<span class="sd">            The highest order of the kurtosis indices required.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dict comprising of kurtosis indices and constitutent mixed orders of the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_statistics</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span><span class="o">.</span><span class="n">get_conditional_kurtosis</span><span class="p">(</span><span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.set_model"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.set_model">[docs]</a>    <span class="k">def</span> <span class="nf">set_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_grads</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the coefficients of the polynomial via the method selected.</span>

<span class="sd">        If model evaluations and/or gradients have not yet been provided to Poly via ``sample-outputs`` and/or ``sample-gradients``, they can be given here via the ``model`` and ``model_grads`` arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : ~collections.abc.Callable,numpy.ndarray</span>
<span class="sd">            The function that needs to be approximated. In the absence of a callable function, the input can be a ndarray model evaluations at the quadrature points.</span>
<span class="sd">        model_grads : ~collections.abc.Callable,numpy.ndarray</span>
<span class="sd">            The gradient of the function that needs to be approximated. In the absence of a callable gradient function, the input can be a ndarray of gradient evaluations at the quadrature points.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Defining a simple univariate example</span>
<span class="sd">            &gt;&gt;&gt; x = np.linspace(-2,2,20).reshape(-1,1)</span>
<span class="sd">            &gt;&gt;&gt; f = lambda x: x**2 - 1</span>
<span class="sd">            &gt;&gt;&gt; param = eq.Parameter(lower=-2,upper=2,order=2)</span>
<span class="sd">            &gt;&gt;&gt; basis = eq.Basis(&#39;univariate&#39;)</span>

<span class="sd">        Least-squares regression of existing data</span>
<span class="sd">            &gt;&gt;&gt; y = f(x)</span>
<span class="sd">            &gt;&gt;&gt; poly = eq.Poly(param,basis,method=&#39;least-squares&#39;,sampling_args={&#39;mesh&#39;: &#39;user-defined&#39;,&#39;sample-points&#39;:x,&#39;sample-outputs&#39;:y})</span>
<span class="sd">            &gt;&gt;&gt; poly.set_model()</span>
<span class="sd">            &gt;&gt;&gt; eq.datasets.score(f(xtest),poly.get_polyfit(xtest),metric=&#39;rmse&#39;)</span>
<span class="sd">            5.438959822042073e-16</span>

<span class="sd">        Numerical integration with model provided as a callable function</span>
<span class="sd">            &gt;&gt;&gt; poly = eq.Poly(param,basis,method=&#39;numerical-integration&#39;)</span>
<span class="sd">            &gt;&gt;&gt; poly.set_model(f)</span>
<span class="sd">            &gt;&gt;&gt; eq.datasets.score(f(xtest),poly.get_polyfit(xtest),metric=&#39;rmse&#39;)</span>
<span class="sd">            5.363652779335998e-15</span>

<span class="sd">        Numerical integration, manually providing model evaluations at quadrature points</span>
<span class="sd">            &gt;&gt;&gt; poly = eq.Poly(param,basis,method=&#39;numerical-integration&#39;)</span>
<span class="sd">            &gt;&gt;&gt; x = poly.get_points()</span>
<span class="sd">            &gt;&gt;&gt; y = f(x)</span>
<span class="sd">            &gt;&gt;&gt; poly.set_model(y)</span>
<span class="sd">            &gt;&gt;&gt; eq.datasets.score(f(xtest),poly.get_polyfit(xtest),metric=&#39;rmse&#39;)</span>
<span class="sd">            5.363652779335998e-15</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            model values should be a column vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">evaluate_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">model</span>
                <span class="c1"># TODO: This error gives messages that are usually not clear</span>
                <span class="k">assert</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;model values should be a column vector.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient_flag</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">model_grads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gradients</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">grad_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradients</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">model_grads</span><span class="p">):</span>
                        <span class="n">grad_values</span> <span class="o">=</span> <span class="n">evaluate_model_gradients</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span><span class="p">,</span> <span class="n">model_grads</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">grad_values</span> <span class="o">=</span> <span class="n">model_grads</span>
                <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">grad_values</span><span class="o">.</span><span class="n">shape</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_evaluations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_weights</span><span class="p">))</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_evaluations</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">grad_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">del</span> <span class="n">grad_values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statistics_object</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_coefficients</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_set_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_defined_coefficients</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the polynomial approximation coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        user_defined_coefficients : numpy.ndarray, optional</span>
<span class="sd">            A numpy.ndarray of shape (N, 1) where N corresponds to the N coefficients provided by the user</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check to ensure that if there any NaNs, a different basis must be used and solver must be changed</span>
        <span class="c1"># to least squares!</span>
        <span class="k">if</span> <span class="n">user_defined_coefficients</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">=</span> <span class="n">user_defined_coefficients</span>
            <span class="k">return</span>
        <span class="n">indices_with_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span><span class="p">))[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_with_nans</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: One or more of your model evaluations have resulted in an NaN. We found &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices_with_nans</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaNs out of &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The code will now use a least-squares technique that will ignore input-output pairs of your model that have NaNs. This will likely compromise computed statistics.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span><span class="p">,</span> <span class="n">indices_with_nans</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span><span class="p">,</span> <span class="n">indices_with_nans</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subsampling_algorithm_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">number_of_basis_to_prune_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">cardinality</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">number_of_basis_to_prune_down</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">prune</span><span class="p">(</span><span class="n">number_of_basis_to_prune_down</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span> <span class="c1"># To make it an over-determined system!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;least-squares&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="s1">&#39;user-defined&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_solver</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_points_and_weights</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_model</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">==</span> <span class="s1">&#39;sparse-grid&#39;</span><span class="p">:</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">multi_index</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">multindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrature</span><span class="o">.</span><span class="n">list</span><span class="p">:</span>
                <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">weights</span><span class="p">))</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span> <span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span> <span class="p">[</span><span class="n">tensor</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">))</span> <span class="k">if</span>  <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
                <span class="k">del</span> <span class="n">counts</span><span class="p">,</span> <span class="n">indices</span>
                <span class="n">coefficients_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">get_coefficients</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrature</span><span class="o">.</span><span class="n">sparse_weights</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span>
                <span class="n">multindices_i</span> <span class="o">=</span>  <span class="n">tensor</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span>
                <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">coefficients_i</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">])</span>
                <span class="n">multindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">multindices_i</span><span class="p">,</span> <span class="n">multindices</span><span class="p">])</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span>  <span class="mi">1</span>
            <span class="n">multindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">multindices</span><span class="p">,</span> <span class="n">multindices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">unique_indices</span><span class="p">,</span> <span class="n">indices</span> <span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">multindices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">coefficients_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">unique_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">multindices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">(</span> <span class="n">unique_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="p">,</span> <span class="n">multindices</span><span class="p">[</span><span class="n">j</span><span class="p">,:]):</span>
                        <span class="n">coefficients_final</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">coefficients_final</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">=</span> <span class="n">coefficients_final</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">unique_indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_weights</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span> <span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient_flag</span><span class="p">:</span>
                <span class="c1"># Now, we can reduce the number of rows!</span>
                <span class="n">dP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly_grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span><span class="p">)</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">cell2matrix</span><span class="p">(</span><span class="n">dP</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">])</span>
                <span class="n">r</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
                <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span> <span class="n">shape</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Gradient computation: The rank of the stacked matrix is &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The number of unknown basis terms is &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Please increase the number of samples; one way to do this would be to increase the sampling-ratio.&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">get_coefficients</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_evaluations</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">get_coefficients</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<div class="viewcode-block" id="Poly.get_multi_index"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_multi_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_multi_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the multi-index set of the basis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of the coefficients with size (cardinality_of_basis, dimensions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span></div>

<div class="viewcode-block" id="Poly.get_coefficients"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_coefficients">[docs]</a>    <span class="k">def</span> <span class="nf">get_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the coefficients of the polynomial approximation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The coefficients with size (number_of_coefficients, 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span></div>

<div class="viewcode-block" id="Poly.get_points"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the samples based on the sampling strategy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The sampled quadrature points with shape (number_of_samples, dimension).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span></div>

<div class="viewcode-block" id="Poly.get_weights"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_weights">[docs]</a>    <span class="k">def</span> <span class="nf">get_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes quadrature weights.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of the corresponding quadrature weights with shape (number_of_samples, 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_weights</span></div>

<div class="viewcode-block" id="Poly.get_points_and_weights"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_points_and_weights">[docs]</a>    <span class="k">def</span> <span class="nf">get_points_and_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the samples and weights based on the sampling strategy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Tuple containing two ndarrays; the sampled quadrature points with shape (number_of_samples, dimension), and the corresponding quadrature weights with shape (number_of_samples, 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_weights</span></div>

<div class="viewcode-block" id="Poly.get_polyfit"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_polyfit">[docs]</a>    <span class="k">def</span> <span class="nf">get_polyfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack_of_points</span><span class="p">,</span> <span class="n">uq</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Evaluates the /polynomial approximation of a function (or model data) at prescribed points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stack_of_points : numpy.ndarray</span>
<span class="sd">            An ndarray with shape (number_of_observations, dimensions) at which the polynomial fit must be evaluated at.</span>
<span class="sd">        uq : bool, optional</span>
<span class="sd">            If ``True``, the estimated uncertainty (standard deviation) of the polynomial approximation is also returned (see [5]).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array with shape (1, number_of_observations) corresponding to the polynomial approximation of the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">uq</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_polystd</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Poly.get_polyfit_grad"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_polyfit_grad">[docs]</a>    <span class="k">def</span> <span class="nf">get_polyfit_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack_of_points</span><span class="p">,</span> <span class="n">dim_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Evaluates the gradient of the polynomial approximation of a function (or model data) at prescribed points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stack_of_points : numpy.ndarray</span>
<span class="sd">            An ndarray with shape (number_of_observations, dimensions) at which the polynomial fit approximation&#39;s gradient must be evaluated at.</span>
<span class="sd">        dim_index : int, optional</span>
<span class="sd">            Index of dimension to evaluate gradient for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of shape (dimensions, number_of_observations) corresponding to the polynomial gradient approximation of the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stack_of_points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">no_of_points</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">no_of_points</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stack_of_points</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly_grad</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">,</span> <span class="n">dim_index</span><span class="o">=</span><span class="n">dim_index</span><span class="p">)</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">no_of_points</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,),</span>  <span class="n">H</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="n">grads</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span> <span class="p">,</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">grads</span></div>

<div class="viewcode-block" id="Poly.get_polyfit_hess"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_polyfit_hess">[docs]</a>    <span class="k">def</span> <span class="nf">get_polyfit_hess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack_of_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Evaluates the hessian of the polynomial approximation of a function (or model data) at prescribed points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------_-</span>
<span class="sd">        stack_of_points : numpy.ndarray</span>
<span class="sd">            An ndarray with shape (number_of_observations, dimensions) at which the polynomial fit approximation&#39;s Hessian must be evaluated at.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of shape (dimensions, dimensions, number_of_observations) corresponding to the polynomial Hessian approximation of the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stack_of_points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">no_of_points</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">no_of_points</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stack_of_points</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly_hess</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="o">.</span><span class="n">T</span> <span class="p">,</span> <span class="n">H</span><span class="p">)</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">no_of_points</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
                <span class="n">hess</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="o">.</span><span class="n">T</span> <span class="p">,</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">+</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">hess</span></div>

<div class="viewcode-block" id="Poly.get_polyfit_function"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_polyfit_function">[docs]</a>    <span class="k">def</span> <span class="nf">get_polyfit_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a callable polynomial approximation of a function (or model data).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ~collections.abc.Callable</span>
<span class="sd">            A callable function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Poly.get_polyfit_grad_function"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_polyfit_grad_function">[docs]</a>    <span class="k">def</span> <span class="nf">get_polyfit_grad_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a callable for the gradients of the polynomial approximation of a function (or model data).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ~collections.abc.Callable</span>
<span class="sd">            A callable function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_polyfit_grad</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.get_polyfit_hess_function"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_polyfit_hess_function">[docs]</a>    <span class="k">def</span> <span class="nf">get_polyfit_hess_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a callable for the hessian of the polynomial approximation of a function (or model data).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ~collections.abc.Callable</span>
<span class="sd">            A callable function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_polyfit_hess</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.get_poly"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_poly">[docs]</a>    <span class="k">def</span> <span class="nf">get_poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack_of_points</span><span class="p">,</span> <span class="n">custom_multi_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Evaluates the value of each polynomial basis function at a set of points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stack_of_points : numpy.ndarray</span>
<span class="sd">            An ndarray with shape (number of observations, dimensions) at which the polynomial must be evaluated.</span>
<span class="sd">        custom_multi_index : numpy.ndarray, optional</span>
<span class="sd">            Array containing a custom multi-index set, in the format given by :meth:`~equadratures.basis.Basis.get_elements`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of shape (cardinality, number_of_observations) corresponding to the polynomial basis function evaluations at the stack_of_points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">custom_multi_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">custom_multi_index</span>
        <span class="n">basis_entries</span><span class="p">,</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">stack_of_points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">no_of_points</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">no_of_points</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stack_of_points</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Save time by returning if univariate!</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">poly</span> <span class="p">,</span> <span class="n">_</span> <span class="p">,</span> <span class="n">_</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_get_orthogonal_polynomial</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">basis</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">poly</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack_of_points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">stack_of_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stack_of_points</span><span class="p">])</span>
                <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">,</span> <span class="n">_</span> <span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_get_orthogonal_polynomial</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">basis</span><span class="p">[:,</span><span class="n">i</span><span class="p">]))</span> <span class="p">)</span>

        <span class="c1"># One loop for polynomials</span>
        <span class="n">polynomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">basis_entries</span><span class="p">,</span> <span class="n">no_of_points</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="n">basis_entries_this_dim</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">polynomial</span> <span class="o">*=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">basis_entries_this_dim</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;inv_R_Psi&#39;</span><span class="p">):</span>
            <span class="n">polynomial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_R_Psi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">polynomial</span>
        <span class="k">return</span> <span class="n">polynomial</span></div>

<div class="viewcode-block" id="Poly.get_poly_grad"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_poly_grad">[docs]</a>    <span class="k">def</span> <span class="nf">get_poly_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack_of_points</span><span class="p">,</span> <span class="n">dim_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Evaluates the gradient for each of the polynomial basis functions at a set of points, with respect to each input variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stack_of_points : numpy.ndarray</span>
<span class="sd">            An ndarray with shape (number_of_observations, dimensions) at which the gradient must be evaluated.</span>
<span class="sd">        dim_index : int, optional</span>
<span class="sd">            Index of the dimension to evaluate the gradient for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list with d elements, where d corresponds to the dimension of the problem. Each element is a numpy.ndarray of shape (cardinality, number_of_observations) corresponding to the gradient polynomial evaluations at the stack_of_points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># &quot;Unpack&quot; parameters from &quot;self&quot;</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span>
        <span class="n">basis_entries</span><span class="p">,</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack_of_points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># a 1d array of inputs, and each input is 1d</span>
                <span class="n">stack_of_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># a 1d array representing 1 point, in multiple dimensions!</span>
                <span class="n">stack_of_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stack_of_points</span><span class="p">])</span>
        <span class="n">no_of_points</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stack_of_points</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Save time by returning if univariate!</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_</span> <span class="p">,</span> <span class="n">dpoly</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_get_orthogonal_polynomial</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">dpoly</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack_of_points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">stack_of_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stack_of_points</span><span class="p">])</span>
                <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_get_orthogonal_polynomial</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">basis</span><span class="p">[:,</span><span class="n">i</span><span class="p">]))</span> <span class="p">)</span>

        <span class="c1"># One loop for polynomials</span>
        <span class="n">R</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">dim_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim_index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">dim_index</span><span class="p">):</span>
                <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">basis_entries</span><span class="p">,</span> <span class="n">no_of_points</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">polynomialgradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">basis_entries</span><span class="p">,</span> <span class="n">no_of_points</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
                    <span class="n">basis_entries_this_dim</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="n">v</span><span class="p">:</span>
                        <span class="n">polynomialgradient</span> <span class="o">*=</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">basis_entries_this_dim</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">polynomialgradient</span> <span class="o">*=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">basis_entries_this_dim</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;inv_R_Psi&#39;</span><span class="p">):</span>
                    <span class="n">polynomialgradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_R_Psi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">polynomialgradient</span>
                <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polynomialgradient</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="Poly.get_poly_hess"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_poly_hess">[docs]</a>    <span class="k">def</span> <span class="nf">get_poly_hess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack_of_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Evaluates the Hessian for each of the polynomial basis functions at a set of points, with respect to each input variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stack_of_points : numpy.ndarray</span>
<span class="sd">            An ndarray with shape (number_of_observations, dimensions) at which the Hessian must be evaluated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list with d^2 elements, where d corresponds to the dimension of the model. Each element is a numpy.ndarray of shape (cardinality, number_of_observations) corresponding to the hessian polynomial evaluations at the stack_of_points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># &quot;Unpack&quot; parameters from &quot;self&quot;</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">elements</span>
        <span class="n">basis_entries</span><span class="p">,</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">stack_of_points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">no_of_points</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">no_of_points</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stack_of_points</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">d2p</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Save time by returning if univariate!</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">d2poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_get_orthogonal_polynomial</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">basis</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">d2poly</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack_of_points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">stack_of_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stack_of_points</span><span class="p">])</span>
                <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">d2p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_get_orthogonal_polynomial</span><span class="p">(</span><span class="n">stack_of_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                                                       <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">basis</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">H</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
            <span class="n">gradDirection1</span> <span class="o">=</span> <span class="n">w</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
                <span class="n">gradDirection2</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">polynomialhessian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">basis_entries</span><span class="p">,</span> <span class="n">no_of_points</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">basis_entries</span><span class="p">):</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">no_of_points</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">gradDirection1</span> <span class="o">==</span> <span class="n">gradDirection2</span><span class="p">:</span>
                            <span class="n">polynomialhessian</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">d2p</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">])]</span> <span class="o">*</span> <span class="n">temp</span>
                        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">gradDirection1</span><span class="p">:</span>
                            <span class="n">polynomialhessian</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">])]</span> <span class="o">*</span> <span class="n">temp</span>
                        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">gradDirection2</span><span class="p">:</span>
                            <span class="n">polynomialhessian</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">])]</span> <span class="o">*</span> <span class="n">temp</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">polynomialhessian</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">])]</span> <span class="o">*</span> <span class="n">temp</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">polynomialhessian</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;inv_R_Psi&#39;</span><span class="p">):</span>
                    <span class="n">polynomialhessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_R_Psi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">polynomialhessian</span>
                <span class="n">H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polynomialhessian</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H</span></div>
<div class="viewcode-block" id="Poly.get_polyscore"><a class="viewcode-back" href="../../poly.html#equadratures.poly.Poly.get_polyscore">[docs]</a>    <span class="k">def</span> <span class="nf">get_polyscore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X_test</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">y_test</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;adjusted_r2&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Evaluates the accuracy of the polynomial approximation using the selected accuracy metric.</span>

<span class="sd">        Training accuracy is evaluated on the data used for fitting the polynomial. Testing accuracy is evaluated on new data if it is provided by the ``X_test`` and ``y_test`` arguments (both must be provided together).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_test : numpy.ndarray, optional</span>
<span class="sd">            An ndarray with shape (number_of_observations, dimensions), containing new data ``X_test`` data (optional).</span>
<span class="sd">        y_test : numpy.ndarray, optional</span>
<span class="sd">            An ndarray with shape (number_of_observations, 1) containing new ``y_test`` data (optional).</span>
<span class="sd">        metric : str, optional</span>
<span class="sd">            An optional string containing the scoring metric to use. Avaliable options are: ``adjusted_r2``, ``r2``, ``mae``, ``rmse``, or ``normalised_mae`` (default: ``adjusted_r2``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            If ``X_test`` and ``y_test`` are ``None``. The training score of the model, output as a float.</span>
<span class="sd">        tuple</span>
<span class="sd">            If ``X_test`` and ``y_test`` are given. Tuple containing the train and test scores of the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_polyfit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">train_score</span> <span class="o">=</span> <span class="n">score</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X_test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y_test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_pred_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_polyfit</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
            <span class="n">test_score</span> <span class="o">=</span> <span class="n">score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_pred_test</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="n">X</span><span class="o">=</span><span class="n">X_test</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">train_score</span><span class="p">,</span> <span class="n">test_score</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">train_score</span></div>

    <span class="k">def</span> <span class="nf">_get_polystd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack_of_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Private function to evaluate the uncertainty of the polynomial approximation at prescribed points, following the approach from [5].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stack_of_points : numpy.ndarray</span>
<span class="sd">            An ndarray with shape (number_of_observations, dimensions) at which the polynomial variance must be evaluated at.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of shape (number_of_observations,1) corresponding to the uncertainty (one standard deviation) of the polynomial approximation at each point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Training data</span>
        <span class="n">X_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_evaluations</span>

        <span class="c1"># Define covariance matrix - TODO: allow non-diagonal matrix?</span>
        <span class="c1"># Empirical variance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_variances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mse</span> <span class="o">=</span> <span class="p">((</span><span class="n">y_train</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_polyfit</span><span class="p">(</span><span class="n">X_train</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">data_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">mse</span><span class="p">)</span>
        <span class="c1"># User defined variance (scalar)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_variances</span><span class="p">):</span>
            <span class="n">data_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">output_variances</span><span class="p">)</span>
        <span class="c1"># User defined variance (array)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_variances</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">data_variance</span><span class="p">)</span>

        <span class="c1"># Construct Q, the pseudoinverse of the weighted orthogonal polynomial matrix P</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_points</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quadrature_weights</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">_inv</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="p">),</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Construct A matrix for test points, but omit weights</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">stack_of_points</span>
        <span class="n">Po</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_poly</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
        <span class="n">Ao</span> <span class="o">=</span> <span class="n">Po</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Propagate the uncertainties</span>
        <span class="n">Sigma_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">),</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">Sigma_F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ao</span><span class="p">,</span> <span class="n">Sigma_X</span><span class="p">),</span> <span class="n">Ao</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">std_F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Sigma_F</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">std_F</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_inv</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function to compute inverse of matrix M, where M is a numpy.ndarray.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ll</span><span class="p">,</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">M2</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="mf">1e-10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>
    <span class="n">inv_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="n">inv_M</span> <span class="o">=</span> <span class="n">inv_L</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">inv_L</span>
    <span class="k">return</span> <span class="n">inv_M</span>

<div class="viewcode-block" id="evaluate_model_gradients"><a class="viewcode-back" href="../../poly.html#equadratures.poly.evaluate_model_gradients">[docs]</a><span class="k">def</span> <span class="nf">evaluate_model_gradients</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">fungrad</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates the model gradient at given values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : numpy.ndarray</span>
<span class="sd">        An ndarray with shape (number_of_observations, dimensions) at which the gradient must be evaluated.</span>
<span class="sd">    fungrad : ~collections.abc.Callable</span>
<span class="sd">        A callable argument for the function&#39;s gradients.</span>
<span class="sd">    format : str, optional</span>
<span class="sd">        The format in which the output is to be provided: ``matrix`` will output a numpy.ndarray of shape (number_of_observations, dimensions) with gradient values, while ``vector`` will stack all the vectors in this matrix to yield a numpy.ndarray with shape (number_of_observations x dimensions, 1).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Array of gradient evaluations.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;matrix&#39;</span><span class="p">:</span>
        <span class="n">grad_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="n">dimensions</span><span class="p">))</span>
        <span class="c1"># For loop through all the points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
            <span class="n">output_from_gradient_call</span> <span class="o">=</span> <span class="n">fungrad</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
                <span class="n">grad_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_from_gradient_call</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">grad_values</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;vector&#39;</span><span class="p">:</span>
        <span class="n">grad_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">*</span> <span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># For loop through all the points</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
            <span class="n">output_from_gradient_call</span> <span class="o">=</span> <span class="n">fungrad</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
                <span class="n">grad_values</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_from_gradient_call</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="n">grad_values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;evalgradients(): Format must be either matrix or vector!&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="evaluate_model"><a class="viewcode-back" href="../../poly.html#equadratures.poly.evaluate_model">[docs]</a><span class="k">def</span> <span class="nf">evaluate_model</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates the model function at given values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : numpy.ndarray</span>
<span class="sd">        An ndarray with shape (number_of_observations, dimensions) at which the gradient must be evaluated.</span>
<span class="sd">    function : ~collections.abc.Callable</span>
<span class="sd">        A callable argument for the function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Array of function evaluations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">function_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
        <span class="n">function_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="k">return</span> <span class="n">function_values</span></div>

<div class="viewcode-block" id="vector_to_2D_grid"><a class="viewcode-back" href="../../poly.html#equadratures.poly.vector_to_2D_grid">[docs]</a><span class="k">def</span> <span class="nf">vector_to_2D_grid</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">index_set</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Handy function that converts a vector of coefficients into a matrix based on index set values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coefficients : numpy.ndarray</span>
<span class="sd">        An ndarray with shape (N, 1) where N corresponds to the number of coefficient values.</span>
<span class="sd">    index_set :  numpy.ndarray</span>
<span class="sd">        The multi-index set of the basis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        Tuple (x,y,z,max_order), containing the x,y values of the meshgrid, the coefficient values, and the highest order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">index_set</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">max_order</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">max_order</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">))</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">index_set</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
    <span class="n">z</span><span class="p">[</span><span class="n">indices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">coefficients</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">max_order</span></div>

<span class="k">def</span> <span class="nf">cell2matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">G0</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Which by default has to exist!</span>
    <span class="n">C0</span> <span class="o">=</span> <span class="n">G0</span><span class="o">.</span><span class="n">T</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">C0</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">BigC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dimensions</span><span class="o">*</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">BigC</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">BigC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="n">BigC</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BigC</span>
</pre></div>

              </div>
              
              
          </main>
          

      </div>
    </div>

    
  <script src="../../_static/js/index.d3f166471bb80abb5163.js"></script>


    <footer>
  <div class="footer">
             <div class="container">
                 <div class="row">
                   <div class="col-md-6 col-lg-3">
                       <div class="footer-about">
                            <img style="float: left; margin: 0px 250px 2px 10px; width:50%; min-width:25px" src="./icons/logo.png" alt="Image"><br>
                            <b>equadratures</b> <br>
                            mail@equadratures.org <br>
                       </div>
                   </div>
                   <div class="col-md-6 col-lg-3">
                       <div class="footer-social">
                           <a href="https://github.com/portrait-code"><img alt="" src="icons/github.png" hspace="0x" style="width:100%; min-width:25px"></a>
                           <a href="https://www.linkedin.com/company/portrait-tec"><img alt=""  src="icons/linkedin.png" hspace="0x" style="width:100%; min-width:25px"></a>
                          <a href="https://twitter.com/PortraitTec"><img alt="" src="icons/twitter.png" hspace="0x" style="width:100%; min-width:25px"></a>
                        <a href="https://twitter.com/PortraitTec"><img alt="" src="icons/youtube.png" hspace="0x" style="width:100%; min-width:25px"></a>
                       </div>
                       <br>
                       <br>
                   </div>
                   <div class="col-md-6 col-lg-3">
                       <div class="footer-contact">
                         <b>management </b><br>
                          team <br>
                          partnerships <br>
                          digital & ai upskilling <br>
                          case studies <br>
                          <a href="https://research.equadratures.org/">research</a><br>
                       </div>
                   </div>
                     <div class="col-md-6 col-lg-3">
                         <div class="footer-links">
                             <b>code </b><br>
                              overview <br>
                              documentation <br>
                              tutorials <br>
                              <a href="https://discourse.equadratures.org/">discourse</a>
                              numfocus affiliation <br>
                              google summer of code <br>
                         </div>
                     </div>
                 </div>
             </div>
             <center>
               <div class="small">
               copyright &copy; 2021 by equadratures.
               <br>
               made by the equadratures team, with &#10084;&#65039;.
             </div>
               <br>
               <br>
             </center>
         </div>
</footer>
  </body>
</html>